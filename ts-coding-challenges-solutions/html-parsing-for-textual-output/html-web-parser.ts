import {load} from "cheerio";
import puppeteer from "puppeteer";
import {fetchAndSaveContent, getLineSeparator} from "./lib/process-html-content";
import {
  DEFAULT_OUTPUT_FOLDER,
  DEFAULT_OUTPUT_FOLDER_HTML,
  DEFAULT_OUTPUT_FOLDER_LOCK,
  DEFAULT_OUTPUT_FOLDER_STORAGE
} from "./lib/constants";

const {Worker} = require("node:worker_threads");
const fs = require('fs')

async function parseAndDownloadLinks(targetUrl: string, html: string, outputFolder: string) {
  // Use Cheerio to parse the static HTML
  const $ = load(html,);

  // Get all hyperlinks in the webpage
  const links = new Set<string>();
  $("a").each((_, elem) => {
    const link = $(elem).attr("href");
    if (link) {
      links.add(new URL(link, targetUrl).href);
    }
  });

  // Use Puppeteer to parse dynamic links generated by JavaScript
  const browser = await puppeteer.launch({headless: "new"});
  const page = await browser.newPage();
  await page.goto(targetUrl);

  // Add a general click listener to capture onClick changes
  await page.addScriptTag({
    content: `
      document.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement) {
          const link = event.target.closest('a[href]');
          if (link) {
            window.linkCollector = window.linkCollector || [];
            window.linkCollector.push(link.href);
          }
        }
        
        // Add the event listener for browser URL change.
        const originalLocation = window.location.href;
        window.addEventListener('popstate', (event) => {
          window.linkCollector = window.linkCollector || [];
          window.linkCollector.push(document.location);
        });
      });
    `,
  });

  const jsLinks = await page.$$eval("a", (anchors) => {
      const links = anchors.map((anchor: HTMLAnchorElement) => anchor.href)
      return links.concat((window as any).linkCollector || []);
    }
  );

  jsLinks.forEach((link: string) => links.add(new URL(link, targetUrl).href));

  await browser.close();

  // Fetch and save content of each link
  const allPromises: Array<Promise<string[]>> = []
  for (const link of links) {
    allPromises.push(fetchAndSaveContent(targetUrl, link))
  }

  const htmlContent = await Promise.all(allPromises);
  let overallContent = "";
  for (const hc of htmlContent) {
    overallContent += hc[1]
  }

  return new Promise<void>((resolve) => {
    const runningWorkers: Array<number> = [];
    for (let i = 0; i < htmlContent.length; i++) {
      runningWorkers.push(i);
    }

    const handleErrorOrNot = (link: string, err: any) => {
      console.info(`Worker for link: [${link}] running...`);
      if (err) {
        console.error("Worker error: ", err)
      }
      console.info(getLineSeparator())
    }

    const handleWorkerRunCompleted = (link: string, err: any) => {
      runningWorkers.pop();
      console.error(`Worker for link: [${link}] exited with status: `, err)
      console.info("Remaining workers: ", runningWorkers.length)
      console.info(getLineSeparator())

      if (runningWorkers.length === 0) {
        // last running worker. resolve this promise.
        resolve();
      }
    }
    for (const hc of htmlContent) {
      // run getting similarity index for each textual content in a separate thread to improve performance.
      const worker = new Worker(
        __dirname + `/lib/save-html-content-to-file.js`,
        {
          workerData: {
            link: hc[0],
            outputFolder,
            textContent: hc[1],
            overallContent: overallContent
          }
        }
      );
      worker.on('message', () => {
        const link = hc[0];
        handleErrorOrNot(link, "")
      });
      worker.on('error', (err: any) => {
        const link = hc[0];
        handleErrorOrNot(link, err)
      });
      worker.on('exit', (code: number) => {
        const link = hc[0];
        handleWorkerRunCompleted(link, code)
      });
    }
  });
}

const ABORT_MISSION_COMMAND = "forfeit-mission";

const main = async () => {
  let targetUrl;

  process.argv.forEach(function (val, index) {
    // by default, index 0 is the command being run, index 1 is the file being run.
    // So passing arguments will start from index 2.
    if (index === 2) {
      if (val.includes("help")) {
        // Regardless of how they specify help (--help, -help, help), as long as there's the word help,
        // print this help statement.
        console.info(`Prerequisites: ${getLineSeparator()}` +
          "'node' in this help statement refers to any program/package that can parse " +
          `javascript or typescript files and execute them.${getLineSeparator()}` +
          `Commands ${getLineSeparator()}To print this help statement, type: 'node help'${getLineSeparator()}` +
          `To specify targetUrl (required) type in: 'node https://google.com' where 'https://google.com' is targetUrl${getLineSeparator()}`);
        targetUrl = "forfeit-mission";
      } else {
        targetUrl = val;
      }
    }
  });
  if (!targetUrl) {
    throw Error("[targetUrl] not specified. Pass this as an argument: i.e: 'node https://example.com' where 'https://" +
      "example.com' is the targetUrl")
  }
  if (targetUrl === ABORT_MISSION_COMMAND) {
    return;
  }

  console.info(`Generated files will be saved to: ${DEFAULT_OUTPUT_FOLDER}. Note that this data will be deleted upon reboot.`)

  if (!fs.existsSync(DEFAULT_OUTPUT_FOLDER_HTML)) {
    fs.mkdirSync(DEFAULT_OUTPUT_FOLDER_HTML, {recursive: true});
  }
  if (!fs.existsSync(DEFAULT_OUTPUT_FOLDER_LOCK)) {
    fs.mkdirSync(DEFAULT_OUTPUT_FOLDER_LOCK, {recursive: true});
  }
  if (!fs.existsSync(DEFAULT_OUTPUT_FOLDER_STORAGE)) {
    fs.mkdirSync(DEFAULT_OUTPUT_FOLDER_STORAGE, {recursive: true});
  }

  const content = await fetchAndSaveContent(targetUrl, targetUrl);
  if (content) {
    await parseAndDownloadLinks(targetUrl, content[1], DEFAULT_OUTPUT_FOLDER_HTML);
  }
  console.log(`Finished processing '${targetUrl}'. Check the '${DEFAULT_OUTPUT_FOLDER_HTML}' folder.${getLineSeparator()}`);
};

main().then();