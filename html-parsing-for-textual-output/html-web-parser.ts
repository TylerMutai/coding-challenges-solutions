import {load} from "cheerio";
import puppeteer from "puppeteer";
import fs from "fs";
import {fetchAndSaveContent, getLineSeparator} from "./process-html-content";

async function parseAndDownloadLinks(targetUrl: string, html: string, outputFolder: string) {
  // Use Cheerio to parse the static HTML
  const $ = load(html,);

  // Get all hyperlinks in the webpage
  const links = new Set<string>();
  $("a").each((_, elem) => {
    const link = $(elem).attr("href");
    if (link) {
      links.add(new URL(link, targetUrl).href);
    }
  });

  // Use Puppeteer to parse dynamic links generated by JavaScript
  const browser = await puppeteer.launch({headless: "new"});
  const page = await browser.newPage();
  await page.goto(targetUrl);

  // Add a general click listener to capture onClick changes
  await page.addScriptTag({
    content: `
      document.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement) {
          const link = event.target.closest('a[href]');
          if (link) {
            window.linkCollector = window.linkCollector || [];
            window.linkCollector.push(link.href);
          }
        }
        
        // Add the event listener for browser URL change.
        const originalLocation = window.location.href;
        window.addEventListener('popstate', (event) => {
          window.linkCollector = window.linkCollector || [];
          window.linkCollector.push(document.location);
        });
      });
    `,
  });

  const jsLinks = await page.$$eval("a", (anchors) => {
      const links = anchors.map((anchor: HTMLAnchorElement) => anchor.href)
      return links.concat((window as any).linkCollector || []);
    }
  );

  jsLinks.forEach((link: string) => links.add(new URL(link, targetUrl).href));

  await browser.close();

  // Fetch and save content of each link
  const allPromises: Array<Promise<string[]>> = []
  for (const link of links) {
    allPromises.push(fetchAndSaveContent(targetUrl, link))
  }

  const htmlContent = await Promise.all(allPromises);
  let overallContent = "";
  for (const hc of htmlContent) {
    overallContent += hc[1]
  }

  // run getting similarity index for each textual content in a separate thread to improve performance.
  for (const hc of htmlContent) {
    new Worker(
      __dirname + `/save-html-content-to-file.ts?link=${hc[0]}&output=${outputFolder}&textContent=${hc[1]}&overallContent=${overallContent}`,
    );
  }
}

const DEFAULT_OUTPUT_FOLDER = "/tmp/html-web-parser/output";
const ABORT_MISSION_COMMAND = "forfeit-mission";

(async () => {
  let targetUrl;
  let outputFolder;

  process.argv.forEach(function (val, index) {
    // by default, index o is the command being run, index 1 is the file being run.
    // So passing arguments will start from index 2.
    if (index === 2) {
      if (val.includes("help")) {
        // Regardless of how they specify help (--help, -help, help), as long as there's the word help,
        // print this help statement.
        console.info(`Prerequisites: ${getLineSeparator()}` +
          "'node' in this help statement refers to any program/package that can parse " +
          `javascript or typescript files and execute them.${getLineSeparator()}` +
          `Commands ${getLineSeparator()}To print this help statement, type: 'node help'${getLineSeparator()}` +
          `To specify targetUrl (required) type in: 'node https://google.com' where 'https://google.com' is targetUrl${getLineSeparator()}` +
          `To specify output folder, type in: 'node [targetUrl] output/' where 'output/' is the output folder${getLineSeparator()}`);
        targetUrl = "forfeit-mission";
      } else {
        targetUrl = val;
      }
    }
    if (index === 3) {
      outputFolder = val;
    }
  });
  if (!targetUrl) {
    throw Error("[targetUrl] not specified. Pass this as an argument: i.e: 'node https://example.com' where 'https://" +
      "example.com' is the targetUrl")
  }
  if (targetUrl === ABORT_MISSION_COMMAND) {
    return;
  }

  if (!outputFolder) {
    console.info(`[outputFolder] not provided. will default to: ${DEFAULT_OUTPUT_FOLDER}. Note that this data will be deleted upon reboot.`)
    outputFolder = DEFAULT_OUTPUT_FOLDER;
  }

  if (!fs.existsSync(outputFolder)) {
    fs.mkdirSync(outputFolder, {recursive: true});
  }

  const content = await fetchAndSaveContent(targetUrl, targetUrl);
  if (content) {
    await parseAndDownloadLinks(targetUrl, content[1], outputFolder);
  }
  console.log(`Finished processing '${targetUrl}'. Check the '${outputFolder}' folder.${getLineSeparator()}`);
})();